{"componentChunkName":"component---src-templates-blog-post-index-tsx","path":"/react/2/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://gywlsp.github.io"}},"markdownRemark":{"id":"1827d335-d0f4-5d78-964b-ccf0d32b667c","excerpt":"이 글은 React…","html":"<blockquote>\n<p><strong>이 글은 React 컴포넌트를 만들 때 고려해야할 사항들에 대해 설명한다.</strong></p>\n</blockquote>\n<h1 id=\"컴포넌트를-어떻게-나눌까\" style=\"position:relative;\">컴포넌트를 어떻게 나눌까?<a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%82%98%EB%88%8C%EA%B9%8C\" aria-label=\"컴포넌트를 어떻게 나눌까 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>컴포넌트는 새로운 함수나 객체를 만들 때처럼 만들면 된다. 이때 <strong><u>단일 책임 원칙</u></strong>에 유의해야 한다. 이는 <strong>컴포넌트가 한 가지 일을 하는 것이 이상적</strong>이라는 원칙이다.</p>\n<p>아래는 단일 책임 원칙에 유의하여 컴포넌트를 분리한 예시이다.</p>\n<p><img src=\"https://ko.reactjs.org/static/eb8bda25806a89ebdc838813bdfa3601/6b2ea/thinking-in-react-components.png\" alt=\"https://ko.reactjs.org/static/eb8bda25806a89ebdc838813bdfa3601/6b2ea/thinking-in-react-components.png\"></p>\n<ol>\n<li><code class=\"language-text\">FilterableProductTable</code>(노란색): 예시 전체를 포괄한다.</li>\n<li><code class=\"language-text\">SearchBar</code>(파란색): 모든 유저의 입력(user input)을 받는다.</li>\n<li><code class=\"language-text\">ProductTable</code>(연두색): 유저의 입력(user input)을 기반으로 데이터 콜렉션(data collection)을 필터링 해서 보여준다.</li>\n<li><code class=\"language-text\">ProductCategoryRow</code>(하늘색): 각 카테고리(category)의 헤더를 보여준다.</li>\n<li><code class=\"language-text\">ProductRow</code>(빨강색): 각각의 제품(product)에 해당하는 행을 보여준다.</li>\n</ol>\n<p>또한 UI 일부가 <strong>여러 번 사용</strong>되거나 (Button, Panel, Avatar), UI 일부가 자체적으로 <strong>복잡</strong>한(App, Comment) 경우에도 <strong>별도의 컴포넌트로 분리</strong>하는 게 좋다.</p>\n<h1 id=\"네이밍\" style=\"position:relative;\">네이밍<a href=\"#%EB%84%A4%EC%9D%B4%EB%B0%8D\" aria-label=\"네이밍 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>컴포넌트, props, state, 변수, 함수 등 모두 각각의 <strong><u>역할이 명확히 드러나도록</u> 이름을 지어야</strong> 한다.</p>\n<h2 id=\"컴포넌트\" style=\"position:relative;\">컴포넌트<a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"컴포넌트 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>컴포넌트의 역할을 명확하게 알 수 있도록 이름을 지어야 한다. (ex: <code class=\"language-text\">UserFollowButton</code>)</p>\n<p><strong>재사용되는 컴포넌트라면 <u>범용성을 고려</u></strong>하여 이름을 지어야 한다. (bad: <code class=\"language-text\">CommentAuthorImage</code>, good: <code class=\"language-text\">Avatar</code>)</p>\n<p><strong>구체적인 맥락에서 쓰이는 컴포넌트라면 그 <u>맥락을 알 수 있게</u></strong> 이름을 지어야 한다. (ex. <code class=\"language-text\">RankingHeader</code>)</p>\n<h2 id=\"props\" style=\"position:relative;\">props<a href=\"#props\" aria-label=\"props permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><strong><u>props의 이름은</u></strong> 사용될 context가 아닌 <strong><u>컴포넌트 자체의 관점에서</u> 짓는 것이 좋다.</strong></p>\n<p><code class=\"language-text\">Comment</code> 컴포넌트에 Comment를 단 사람의 프로필 이미지를 나타내는 <code class=\"language-text\">Avatar</code> 컴포넌트가 존재한다고 가정하자.</p>\n<p>Avatar는 자신이 Comment 내에서 렌더링 된다는 것을 알 필요가 없다. 따라서 props의 이름을 author로 쓰는 것보단 user로 쓰는 것이 낫다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Avatar</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Avatar<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>avatarUrl<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">alt</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1 id=\"무엇을-state로\" style=\"position:relative;\">무엇을 state로?<a href=\"#%EB%AC%B4%EC%97%87%EC%9D%84-state%EB%A1%9C\" aria-label=\"무엇을 state로 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>애플리케이션을 올바르게 만들기 위해서는 <strong><u>애플리케이션이 필요로 하는 가장 최소한의 state</u></strong>를 찾고, 이를 통해 나머지 모든 것들이 필요에 따라 그때그때 계산되도록 만들어야 한다.</p>\n<p>핵심은 <strong><u>중복배제원칙</u></strong>이다. 예를 들어 TODO 리스트를 만든다고 하면, TODO 아이템을 저장하는 배열만 유지하고 TODO 아이템의 개수를 표현하는 state를 별도로 만들지 않아도 된다. 배열의 길이를 이용해 TODO 아이템의 개수를 표현하면 되기 때문이다.</p>\n<p>어떤 애플리케이션이 다음과 같은 데이터를 가지고 있다고 가정하자.</p>\n<ul>\n<li>제품의 원본 목록(API에서 데이터를 받음)</li>\n<li>유저가 입력한 검색어</li>\n<li>체크박스의 값</li>\n<li>필터링된 제품들의 목록</li>\n</ul>\n<p>어떤 게 state가 되어야 할까? 이는 아래 <strong>세 가지 질문</strong>을 통해 결정할 수 있다.</p>\n<ol>\n<li><strong>부모로부터 props를 통해 전달되는가?</strong> 그렇다면 state가 아니다.</li>\n<li><strong>시간이 지나도 변하지 않는가?</strong> 그렇다면 state가 아니다.</li>\n<li><strong>컴포넌트 안의 다른 state나 props를 가지고 계산 가능한가?</strong> 그렇다면 state가 아니다.</li>\n</ol>\n<p>위 기준을 가지고 예시 목록들 각각이 state가 되어야 하는지 판단해보자.</p>\n<ul>\n<li>제품의 원본 목록 : state가 아니다. API에서 데이터를 받아 부모로부터 props로 전달되기 때문이다.</li>\n<li>유저가 입력한 검색어, 체크박스 : state이다. 시간이 지남에 따라 변하기도 하면서 다른 것들로부터 계산될 수 없기 때문이다.</li>\n<li>필터링된 제품들의 목록 : state가 아니다. 제품의 원본 목록과 검색어, 체크박스의 값을 조합해서 계산해낼 수 있기 때문이다.</li>\n</ul>\n<h1 id=\"state의-위치\" style=\"position:relative;\">state의 위치?<a href=\"#state%EC%9D%98-%EC%9C%84%EC%B9%98\" aria-label=\"state의 위치 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>어떤 컴포넌트가 어떤 state를 가져야 할지 결정하기 어렵다면 아래 과정을 따라 결정하면 보다 쉽다.</p>\n<p>애플리케이션이 가지는 각각의 state에 대해서</p>\n<ul>\n<li><strong>state를 기반으로 렌더링하는 모든 컴포넌트를 찾는다.</strong></li>\n<li><strong>공통 소유 컴포넌트</strong> (common owner component; 계층 구조 내에서 특정 state가 있어야 하는 모든 컴포넌트들의 상위에 있는 하나의 컴포넌트)<strong>를 찾는다</strong>.</li>\n</ul>\n<p><strong>공통 혹은 더 상위에 있는 컴포넌트가 state를 가져야 한다.</strong> state를 소유할 적절한 컴포넌트가 없다면, state를 소유하는 컴포넌트를 하나 만들어서 공통 오너 컴포넌트의 상위 계층에 추가하면 된다.</p>\n<p>다른 컴포넌트 간에 존재하는 state를 동기화하려고 노력하는 대신, <strong><u>상위 컴포넌트에 하나의 state를 두고 하향식 데이터 흐름에 기대는 것이 좋다.</u></strong></p>\n<h3 id=\"하향식-데이터-흐름\" style=\"position:relative;\">하향식 데이터 흐름<a href=\"#%ED%95%98%ED%96%A5%EC%8B%9D-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84\" aria-label=\"하향식 데이터 흐름 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>트리 구조가 props의 폭포라고 상상하면 각 컴포넌트의 state는 임의의 점에서 만나지만 동시에 아래로 흐르는 부가적인 수원이라고 할 수 있다.</p>\n<p>모든 state는 항상 특정한 컴포넌트가 소유하고 있으며, 그 state로부터 파생된 UI 또는 데이터는 오직 트리구조에서 자신의 아래에 있는 컴포넌트에만 영향을 미친다.</p>\n<p>이를 하향식 데이터 흐름 또는 단방향 데이터 흐름이라고 부른다.</p>\n<p>*React 공식 문서를 바탕으로 작성한 글입니다.</p>","fields":{"slug":"/react/2/"},"tableOfContents":"<ul>\n<li><a href=\"/react/2/#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%82%98%EB%88%8C%EA%B9%8C\">컴포넌트를 어떻게 나눌까?</a></li>\n<li>\n<p><a href=\"/react/2/#%EB%84%A4%EC%9D%B4%EB%B0%8D\">네이밍</a></p>\n<ul>\n<li><a href=\"/react/2/#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">컴포넌트</a></li>\n<li><a href=\"/react/2/#props\">props</a></li>\n</ul>\n</li>\n<li><a href=\"/react/2/#%EB%AC%B4%EC%97%87%EC%9D%84-state%EB%A1%9C\">무엇을 state로?</a></li>\n<li>\n<p><a href=\"/react/2/#state%EC%9D%98-%EC%9C%84%EC%B9%98\">state의 위치?</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/react/2/#%ED%95%98%ED%96%A5%EC%8B%9D-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%9D%90%EB%A6%84\">하향식 데이터 흐름</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[React] 리액트 컴포넌트를 만들 때 고려해야 할 것들","date":"2020-12-06T13:12:48+00:00","description":"이 글은 React 컴포넌트를 만들 때 고려해야 할 사항들에 대해 설명합니다.","tags":["React"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA70lEQVQoz2NQUNb6jxcraWJn48AMhAyTV9X9r6Cg/l9BUR3CJmAoA17D1HT/SwfE/ZcKTQFjaf84sBg+Q7EaKK+i/V9BVvm/rKXLf4m0yv/iha3/xQtagOyK/7IWzmA5sBqiXQj0opye+X+psDSwYSIdC8AYxJYKS/0vp2sGCQaiDVTU+C+vYfBfKijxv3hR+3+xmkn/xaongtkgMXl1faC3NUgJQ6B35FT+y+lb/peMyQUbBMKS0TlAMQuwHHmRoqLzX9or4r+MS+B/GddAIDscEnakRgpKugN6X0FeDYJBbLKTDVqs44pVsgwkBQMAy7BHkFMBPlQAAAAASUVORK5CYII=","aspectRatio":1.7751479289940828,"src":"/static/f76b8509137436aa4367eddaf9b497e6/f3583/thumbnail.png","srcSet":"/static/f76b8509137436aa4367eddaf9b497e6/630fb/thumbnail.png 300w,\n/static/f76b8509137436aa4367eddaf9b497e6/2a4de/thumbnail.png 600w,\n/static/f76b8509137436aa4367eddaf9b497e6/f3583/thumbnail.png 1200w,\n/static/f76b8509137436aa4367eddaf9b497e6/bbee5/thumbnail.png 1800w,\n/static/f76b8509137436aa4367eddaf9b497e6/eeb1b/thumbnail.png 1920w","sizes":"(max-width: 1200px) 100vw, 1200px"}}}}}},"pageContext":{"slug":"/react/2/","previous":{"fields":{"slug":"/boj/1463/"},"frontmatter":{"title":"백준 1463번 1로 만들기 - node.js"}},"next":{"fields":{"slug":"/boj/1931/"},"frontmatter":{"title":"백준 1931번 회의실 배정 - node.js"}}}},"staticQueryHashes":["3000541721","3274528899","3384690500"]}