{"componentChunkName":"component---src-templates-blog-post-index-tsx","path":"/javascript/7/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://gywlsp.github.io"}},"markdownRemark":{"id":"22a796ee-02c3-53bc-89d1-276e6df5da06","excerpt":"프로토타입 자바스크립트는 프로토타입 기반 언어이다. 클래스 기반 언어에서는 ‘상속’을 사용하지만 프로토타입 기반 언어에서는 어떤 객체를 원형(prototype)으로 삼고 이를 복제(참조)함으로써 상속과 비슷한 효과를 얻는다. 어떤 생성자 함수(Constructor…","html":"<h1 id=\"프로토타입\" style=\"position:relative;\">프로토타입<a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85\" aria-label=\"프로토타입 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>자바스크립트는 프로토타입 기반 언어이다. 클래스 기반 언어에서는 ‘상속’을 사용하지만 <strong>프로토타입 기반 언어에서는 어떤 객체를 원형(prototype)으로 삼고 이를 복제(참조)함으로써 상속과 비슷한 효과</strong>를 얻는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<img width=\"240\" alt=\"프로토타입-도식\" src=\"https://user-images.githubusercontent.com/47051596/156561919-3c5f4596-767b-4089-8549-2f611e778746.png\">\n<p>어떤 생성자 함수(Constructor)를 <code class=\"language-text\">new</code> 연산자와 함께 호출하면, Constructor에 정의된 내용을 바탕으로 새로운 인스턴스(instance)가 생성된다. 이때 instance에는 <code class=\"language-text\">__proto__</code>라는 프로퍼티가 자동으로 부여되는데, 이 프로퍼티는 Constructor의 <code class=\"language-text\">prototype</code>이라는 프로퍼티를 참조한다. 이는 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%EB%AC%B8%EB%B2%95_%EC%83%9D%EC%84%B1%EC%9E%90%EB%A1%9C_%EA%B0%9D%EC%B2%B4_%EC%83%9D%EC%84%B1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">문법 생성자</a>(배열 리터럴, 객체 리터럴 등)로 객체를 생성할 때도 마찬가지다.</p>\n<p><strong>prototype</strong>은 객체이고, prototype 객체 내부에는 <strong>인스턴스가 사용할 프로퍼티나 메서드를 저장</strong>한다. <code class=\"language-text\">__proto__</code>는 생성자의 <code class=\"language-text\">prototype</code> 프로퍼티를 참조하기 때문에 인스턴스에서는 <code class=\"language-text\">__proto__</code>를 통해 이 메서드들에 접근할 수 있다.</p>\n<p>예를 들어, <code class=\"language-text\">Person</code>이라는 생성자 함수의 <code class=\"language-text\">prototype</code>에 <code class=\"language-text\">getName</code>이라는 메서드를 지정했다고 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">Person</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">getName</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이때 <code class=\"language-text\">Person</code>의 인스턴스는 <code class=\"language-text\">__proto__</code>프로퍼티를 통해 <code class=\"language-text\">getName</code>을 호출할 수 있다. 왜냐하면 인스턴스의 <code class=\"language-text\">__proto__</code>가 Constructor의 <code class=\"language-text\">prototype</code> 프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라보기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> suzi <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'수지'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsuzi<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">===</span> suzi<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>그러나 여기에서 <code class=\"language-text\">this._name</code>이 ‘수지’가 아니라 <code class=\"language-text\">undefined</code>로 출력되었다. 그 이유는 함수를 메서드 방식으로 호출했기 때문에, <code class=\"language-text\">this</code>가 <code class=\"language-text\">suzi</code>가 아닌 <code class=\"language-text\">suzi.__proto__</code>(메서드명 바로 앞의 객체)가 되기 때문이다. 그리고 프로토타입 객체 내부에 <code class=\"language-text\">name</code> property를 추가한 것이 아니기 때문에 <code class=\"language-text\">undefined</code>가 출력된다.</p>\n<p><code class=\"language-text\">this</code>가 인스턴스가 되도록 하기 위해서는, <code class=\"language-text\">__proto__</code> 없이 곧바로 메서드를 쓰면 된다. <code class=\"language-text\">__proto__</code>는 생략 가능한 프로퍼티이기 때문에, <code class=\"language-text\">__proto__</code>를 생략하더라도 Constructor의 <code class=\"language-text\">prototype</code> 내부의 메서드를 자신의 메서드인 것처럼 호출할 수 있다. 평소에 JavaScript를 사용했던 개발자라면 배열을 담은 변수의 <code class=\"language-text\">length</code> 프로퍼티를 이용하거나 <code class=\"language-text\">concat</code>, <code class=\"language-text\">push</code>, <code class=\"language-text\">forEach</code> 등의 메서드를 호출해본 경험이 있을 것이다. 이것은 앞서 말했듯 <code class=\"language-text\">__proto__</code> 프로퍼티가 생략 가능하도록 설계되어있어 인스턴스가 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">표준 내장 객체</a>의 메서드 및 속성을 자신의 것처럼 호출할 수 있었던 것이다.</p>\n<h1 id=\"프로토타입-체인\" style=\"position:relative;\">프로토타입 체인<a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\" aria-label=\"프로토타입 체인 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>어떤 데이터의 <code class=\"language-text\">__proto__</code> 내부에 다시 <code class=\"language-text\">__proto__</code>가 연쇄적으로 이어진 것을 <strong>프로토타입 체인</strong>이라고 하고, 이 체인을 따라가며 검색하는 것을 <strong>프로토타입 체이닝</strong>이라고 한다. 프로토타입 체이닝을 통해 각 프로토타입 메서드를 자신의 것처럼 호출할 수 있고, 이때 접근 방식은 자신으로부터 가장 가까운 대상부터 점차 먼 대상으로 나아가며, 원하는 값을 찾으면 검색을 중단한다. 아래 예시에서 프로토타입 체인을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">dir</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<img width=\"300\" alt=\"프로토타입-체인-예시\" src=\"https://user-images.githubusercontent.com/47051596/162200498-c22170ae-127f-4298-b02e-c772ff65e6f4.png\">\n<p>어떤 생성자 함수이든 <code class=\"language-text\">prototype</code>은 반드시 ‘객체’이기 때문에 <code class=\"language-text\">Object.prototype</code>이 언제나 프로토타입 체인의 최상단에 존재한다. 그래서 <code class=\"language-text\">Object.prototype</code>에는 모든 데이터 타입에서 사용할 수 있는 범용적인 메서드만이 존재하며, 객체 전용 메서드는 여느 데이터 타입과 달리 Object 생성자 함수에 static하게 담겨있다. 객체에서만 사용할 메서드를 <code class=\"language-text\">Object.prototype</code> 내부에 정의한다면, 다른 데이터 타입도 해당 메서드를 사용할 수 있게 되기 때문이다.</p>\n<p><strong>참고 자료</strong></p>\n<ul>\n<li>책 코어 자바스크립트</li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN 상속과 프로토타입</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN 표준 내장 객체</a></li>\n</ul>","fields":{"slug":"/javascript/7/"},"tableOfContents":"<ul>\n<li><a href=\"/javascript/7/#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85\">프로토타입</a></li>\n<li><a href=\"/javascript/7/#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\">프로토타입 체인</a></li>\n</ul>","frontmatter":{"title":"JavaScript 프로토타입 알아보기","date":"2022-04-07T12:36:50+00:00","description":"이 글은 JavaScript의 프로토타입에 대해 설명한다.","tags":["JavaScript"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGElEQVQoz2P4ct8XjHy+3A/4et/m+32Z7/fl4OjbPRD6fl/+632XL/f9YYqhiAGPZpDO+3I/HwBJEjV/uSv346Hcl/tyr6/I/Hwo/4VIzV/uyP1/o9BbL7h4skhhKl9SBM+jMzI/H7t+vkek5o8KJZn8XbWC9pYcPXWCxPr5x33Zjzfl/79UKM3im9IqfO2gNFD/tHbh/+/cPt7xw6f5yz3rnw+l3l6TTonicrFlWzdXODeJ292RbckUof9vXPFoBiL/r/cdvt3X+vlI595JjVvH1P8/17lzTOPSfrXfT3W+3HP/ch+fZl+wtD8wYH4+CQCij3f9fz4O+PU04NNdf0ydmJoh7vf5fM/n010w4y6UgakTq2YSEADdGrUPlKh55AAAAABJRU5ErkJggg==","aspectRatio":1.7751479289940828,"src":"/static/7b8e01b8299a5ec508bacdece857236d/40ffe/thumbnail.png","srcSet":"/static/7b8e01b8299a5ec508bacdece857236d/630fb/thumbnail.png 300w,\n/static/7b8e01b8299a5ec508bacdece857236d/2a4de/thumbnail.png 600w,\n/static/7b8e01b8299a5ec508bacdece857236d/40ffe/thumbnail.png 960w","sizes":"(max-width: 960px) 100vw, 960px"}}}}}},"pageContext":{"slug":"/javascript/7/","previous":{"fields":{"slug":"/react/4/"},"frontmatter":{"title":"왜 React 컴포넌트/엘리먼트 리스트 항목에 적절한 key를 부여해야 할까?"}},"next":{"fields":{"slug":"/javascript/6/"},"frontmatter":{"title":"JavaScript 이벤트 전파와 위임"}}}},"staticQueryHashes":["3000541721","3274528899","3384690500"]}