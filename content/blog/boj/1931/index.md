---
title: '백준 1931번 회의실 배정 - javascript'
date: '2021-02-17T00:31:17+00:00'
description: '백준 1931번 회의실 배정을 풀이하는 글입니다.'
tags: ['Javascript', 'Algorithm']
thumbnail: 'boj_1931.png'
---

> 이 글은 [백준 1931번 회의실 배정](https://www.acmicpc.net/problem/1931)을 풀이한다. 코드는 javascript로 구현하였다.

# 문제

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, **<u>각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수</u>**를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 **한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다**. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

## 입력

첫째 줄에 회의의 수 N(1 ≤ **N ≤ 100,000**)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. **시작 시간과 끝나는 시간은** 2^31-1보다 작거나 같은 **자연수 또는 0**이다.

### 예제 입력 1

```bash
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
```

## 출력

첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

### 예제 출력 1

```bash
4
```

### 제한

- **시간 제한 : 2초**(대략 2억 번 연산 가능)
- **메모리 제한** : 128MB

## 힌트

(1,4), (5,7), (8,11), (12,14) 를 이용할 수 있다.

# 풀이

## 접근

### 무식하게 풀 수 있을까?

이 문제를 무식하게 푸는 방법은 모든 부분 집합을 만들어 겹치지 않는 답들을 고르고 그 중 가장 큰 부분 집합을 찾는 것이다. 그러나 집합의 크기가 n일 때 부분 집합의 수는 2^n이기 때문에, n이 최대 100,000이 될 수 있는 이 문제는 이 방법으로 시간 내에 풀 수 없다.

### 탐욕적 알고리즘

이 문제는 [탐욕법](https://ko.wikipedia.org/wiki/%ED%83%90%EC%9A%95_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)이 유용하게 사용되는 문제 중 유명한 예시인 **활동 선택 문제**에 해당한다. '탐욕적인 알고리즘'은 원하는 답을 재귀 호출과 똑같이 여러 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어 간다는 점에서 완전 탐색이나 동적 계획법과 동일하다. 그러나 모든 선택지를 고려해 보고 그 중 전체 답이 가장 좋은 것을 찾는 두 방법과는 달리, **탐욕법은 각 단계마다 그 순간 가장 좋은 방법만을 선택**한다.

이 문제를 해결하는 탐욕적인 방법은 **길이와 상관 없이 가장 먼저 끝나는 회의부터 선택**하는 것이다. **가장 먼저 끝나는 회의를 선택하고, 이 회의와 겹치는 것들을 모두 지운 뒤 이 중에서 가장 먼저 끝나는 회의를 선택하기를 반복**하는 것이다.

## 알고리즘

- 회의를 다음과 같은 순서로 정렬한다.
    1. **먼저 끝나는 회의**
    2. 끝나는 시간이 같다면, **먼저 시작하는 회의**
- 정렬된 회의 목록을 순서대로 돌며 다음 과정을 반복한다.
    - 회의가 전에 진행된 회의가 끝나기 전에 시작되면 다음으로
    - 아니면 회의 진행

### 트러블 슈팅

위 알고리즘에서 두 회의의 끝나는 시간이 같을 때 먼저 시작하는 순서대로 회의를 정렬한다. 그 이유는 다음과 같은 입력을 대비하기 위해서이다.

```jsx
2
2 3
1 3
```

## 구현

### 코드

```jsx
const input = [];

const strToNumArr = (str) =>
  str.split(" ").map((numString) => Number(numString));

require("readline")
  .createInterface(process.stdin, process.stdout)
  .on("line", function (line) {
    input.push(line.trim());
  })
  .on("close", function () {
    const N = Number(input.shift());
    //회의를 다음 순서대로 정렬
    //1) 먼저 끝나는 회의
    //2) 끝나는 시간이 같다면, 먼저 시작하는 회의
    const schedule = input
      .map((str) => strToNumArr(str))
      .sort((a, b) => a[1] - b[1] || a[0] - b[0]);

    let result = 0,
      recentEnd = 0;
    schedule.forEach(([start, end]) => {
      //전에 진행된 회의가 끝나기 전에 시작되면 다음으로
      if (start < recentEnd) {
        return;
      }
      //아니면 진행
      result++;
      recentEnd = end;
    });

    console.log(result);
  });
```